#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorNone)
#pragma config(Sensor, in2,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  barLimit,       sensorDigitalIn)
#pragma config(Sensor, dgtl2,  ledCanFire,     sensorDigitalOut)
#pragma config(Sensor, dgtl3,  ledCannotFire,  sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorBar,      tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motorFrontLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorBackLeft, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           motorFrontRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           motorBackRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           motorLauncherOne, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           motorLauncherTwo, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           motorLauncherThree, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorLauncherFour, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          motorIntake,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   // Main competition background code
#include "bar.c" // Launcher bar control
#include "sensors.c" // Sensor methods
#include "autonomous.c" // Autonomous handler
#include "lcd.c" // LCD methods
#include "controller.c" // Controller methods

int firePosition;
bool isFiring;

bool canFire() {
	return (!isFiring && isBarReady());
}

// ##################
// # Pre Autonomous #
// ##################

void pre_auton()
{
	bLCDBacklight = true;
	resetBar();
	//startTask (	barHookPos ); // TODO Uncomment

	// Goodbye, errors
	if (false) {
		UserControlCodePlaceholderForTesting();
		AutonomousCodePlaceholderForTesting();
		startTask( countHoldTime );
	}
}

// ##############
// # Autonomous #
// ##############

task autonomous()
{
	runAutonomous();
}

// ################
// # User Control #
// ################

task usercontrol()
{
	// Hold time currently not used
	//startTask( countHoldTime );
	startTask( lcdRunAutoRefresh );
	startTask( updateBar );
	// Main loop
	bool buttonReleased = true;
	int highestCombination = 0;
	while(true)
	{
		// LED indicators
		if (canFire()) {
			SensorValue[ledCanFire] = 1;
			SensorValue[ledCannotFire] = 0;
		}
		else {
			SensorValue[ledCanFire] = 0;
			SensorValue[ledCannotFire] = 1;
		}
		// LCD Button Handling
		if (nLCDButtons == 0) { // A button wasn't pressed
			if (buttonReleased == false) {
				// Button was pressed then released, calculate what to do
				if (highestCombination == 1) { // Left button pressed
					lcdLastPage();
					buttonReleased = false;
				}
				else
					if (highestCombination == 2) { // Center button pressed
					lcdHome();
					buttonReleased = false;
				}
				else
					if (highestCombination == 4) { // Right button pressed
					lcdNextPage();
					buttonReleased = false;
				}
				else
					if (highestCombination == 3) { // Left & center pressed
					lcdNext();
				}
				else
					if (highestCombination == 6) { // Right & center pressed
					lcdBack();
				}
				buttonReleased = true;
				highestCombination = 0;
			} // Else: Nothing was pressed
		}
		else // A button was pressed
		{
			lcdResetAutoRefresh();
			if (buttonReleased) {
				buttonReleased = false;
				lcdResetHoldTime();
			}

			if (nLCDButtons > highestCombination) {
				highestCombination = nLCDButtons;
			}
		}

		// Controller
		runCalculation();
	}
}

// ####################
// # Launcher Methods #
// ####################

void setLauncherSpeed( int armSpeed ) {
	motor[motorLauncherOne] = armSpeed;
	motor[motorLauncherTwo] = armSpeed;
	motor[motorLauncherThree] = armSpeed;
	motor[motorLauncherFour] = armSpeed;
}

bool isAboutToFire() { // TODO use potentiometer to determine if we're about to shoot
	return true;
}

task fireTask() {
	// Move bar to launch position
	if (firePosition == 1) { // Long range
		startTask( barLongShot );
	}
	else
		if (firePosition == 2) { // Mid range
		startTask( barMediumShot );
	}
	else
		if (firePosition == 3) { // Long range
		startTask( barCloseShot );
	}
	else
		return; // Invalid position

	// Wait for bar to be in position
	setLauncherSpeed(30);
	while (!isBarReady()) { // Wait til bar is in hook position
		// TODO If we're about to fire, slow motors down
		wait1Msec(25);
	}

	// Move arm and intake when ready
	while (true) {
		if (!isAboutToFire()) { // Not about to fire
			setLauncherSpeed(60);
		}
		else // About to fire
		{
			setLauncherSpeed(30);
			// TODO intake 1 ball
			break;
		}
		wait1Msec(25);
	}

	// Stop the motors once we slip
	int prevValue = SensorValue[armPot];
	int currentValue;
	while (true) {
		if (prevValue-currentValue > 200) { // TODO change
			setLauncherSpeed(0);
			break;
		}
		wait1Msec(10);
	}

	// Once we hit the arm reset the bar to hook position
	while (true) {
		if (SensorValue[barLimit] == 1) {
			wait1Msec(300);
			startTask( barHookPos );
			break;
		}
		wait1Msec(25);
	}

	isFiring = false; // Set to false so we can fire again
}

// Position:
// 1 - Long range
// 2 - Mid range
// 3 - Close range
void fire(int position) { // Fire loop
	if (canFire()) {
		firePosition = position;
		isFiring = true;
		startTask(fireTask);
	}
}
